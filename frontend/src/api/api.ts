/**
 * My custom API schema title
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://127.0.0.1:8000".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Data {
    /**
     * 
     */
    "username": string;
    /**
     * 
     */
    "password": string;
}

export interface Data1 {
    /**
     * 
     */
    "number": number;
    /**
     * 
     */
    "template": string;
}

export interface Data10 {
    /**
     * 
     */
    "datafile": string;
    /**
     * 
     */
    "number": number;
    /**
     * 
     */
    "parentPdf": string;
}

export interface Data11 {
    /**
     * 
     */
    "datafile": string;
    /**
     * 
     */
    "number": number;
    /**
     * 
     */
    "parentPdf": string;
}

export interface Data12 {
    /**
     * 
     */
    "datafile"?: string;
    /**
     * 
     */
    "number"?: number;
    /**
     * 
     */
    "parentPdf"?: string;
}

export interface Data13 {
    /**
     * 
     */
    "email": string;
    /**
     * 
     */
    "document": string;
    /**
     * 
     */
    "user"?: string;
}

export interface Data14 {
    /**
     * 
     */
    "email": string;
    /**
     * 
     */
    "document": string;
    /**
     * 
     */
    "user"?: string;
}

export interface Data15 {
    /**
     * 
     */
    "email"?: string;
    /**
     * 
     */
    "document"?: string;
    /**
     * 
     */
    "user"?: string;
}

export interface Data16 {
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "datafile": string;
    /**
     * 
     */
    "pageWidth"?: number;
    /**
     * 
     */
    "pageHeight"?: number;
    /**
     * 
     */
    "owner": string;
}

export interface Data17 {
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "datafile": string;
    /**
     * 
     */
    "pageWidth"?: number;
    /**
     * 
     */
    "pageHeight"?: number;
    /**
     * 
     */
    "owner": string;
}

export interface Data18 {
    /**
     * 
     */
    "name"?: string;
    /**
     * 
     */
    "datafile"?: string;
    /**
     * 
     */
    "pageWidth"?: number;
    /**
     * 
     */
    "pageHeight"?: number;
    /**
     * 
     */
    "owner"?: string;
}

export interface Data19 {
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "pdf": string;
    /**
     * 
     */
    "owner": string;
}

export interface Data2 {
    /**
     * 
     */
    "number": number;
    /**
     * 
     */
    "template": string;
}

export interface Data20 {
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "pdf": string;
    /**
     * 
     */
    "owner": string;
}

export interface Data21 {
    /**
     * 
     */
    "name"?: string;
    /**
     * 
     */
    "pdf"?: string;
    /**
     * 
     */
    "owner"?: string;
}

export interface Data3 {
    /**
     * 
     */
    "number"?: number;
    /**
     * 
     */
    "template"?: string;
}

export interface Data4 {
    /**
     * 
     */
    "top"?: number;
    /**
     * 
     */
    "left"?: number;
    /**
     * 
     */
    "page": string;
    /**
     * 
     */
    "party": string;
    /**
     * 
     */
    "template": string;
}

export interface Data5 {
    /**
     * 
     */
    "top"?: number;
    /**
     * 
     */
    "left"?: number;
    /**
     * 
     */
    "page": string;
    /**
     * 
     */
    "party": string;
    /**
     * 
     */
    "template": string;
}

export interface Data6 {
    /**
     * 
     */
    "top"?: number;
    /**
     * 
     */
    "left"?: number;
    /**
     * 
     */
    "page"?: string;
    /**
     * 
     */
    "party"?: string;
    /**
     * 
     */
    "template"?: string;
}

export interface Data7 {
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "pdf": string;
    /**
     * 
     */
    "owner": string;
}

export interface Data8 {
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "pdf": string;
    /**
     * 
     */
    "owner": string;
}

export interface Data9 {
    /**
     * 
     */
    "name"?: string;
    /**
     * 
     */
    "pdf"?: string;
    /**
     * 
     */
    "owner"?: string;
}

export interface InlineResponse200 {
    /**
     * 
     */
    "results": Array<InlineResponse200Results>;
    /**
     * 
     */
    "next": string;
    /**
     * 
     */
    "previous": string;
    /**
     * 
     */
    "count": number;
}

export interface InlineResponse2001 {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "number": number;
    /**
     * 
     */
    "template": string;
}

export interface InlineResponse20010 {
    /**
     * 
     */
    "results": Array<InlineResponse20010Results>;
    /**
     * 
     */
    "next": string;
    /**
     * 
     */
    "previous": string;
    /**
     * 
     */
    "count": number;
}

export interface InlineResponse20010Results {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "name"?: string;
    /**
     * 
     */
    "datafile"?: string;
    /**
     * 
     */
    "created"?: string;
    /**
     * 
     */
    "pageWidth"?: number;
    /**
     * 
     */
    "pageHeight"?: number;
    /**
     * 
     */
    "owner"?: string;
}

export interface InlineResponse20011 {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "datafile": string;
    /**
     * 
     */
    "created"?: string;
    /**
     * 
     */
    "pageWidth"?: number;
    /**
     * 
     */
    "pageHeight"?: number;
    /**
     * 
     */
    "owner": string;
}

export interface InlineResponse2002 {
    /**
     * 
     */
    "results": Array<InlineResponse2002Results>;
    /**
     * 
     */
    "next": string;
    /**
     * 
     */
    "previous": string;
    /**
     * 
     */
    "count": number;
}

export interface InlineResponse2002Results {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "top"?: number;
    /**
     * 
     */
    "left"?: number;
    /**
     * 
     */
    "page"?: string;
    /**
     * 
     */
    "party"?: string;
    /**
     * 
     */
    "template"?: string;
}

export interface InlineResponse2003 {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "top"?: number;
    /**
     * 
     */
    "left"?: number;
    /**
     * 
     */
    "page": string;
    /**
     * 
     */
    "party": string;
    /**
     * 
     */
    "template": string;
}

export interface InlineResponse2004 {
    /**
     * 
     */
    "results": Array<InlineResponse2004Results>;
    /**
     * 
     */
    "next": string;
    /**
     * 
     */
    "previous": string;
    /**
     * 
     */
    "count": number;
}

export interface InlineResponse2004Results {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "name"?: string;
    /**
     * 
     */
    "createdAt"?: string;
    /**
     * 
     */
    "pdf"?: string;
    /**
     * 
     */
    "owner"?: string;
}

export interface InlineResponse2005 {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "name": string;
    /**
     * 
     */
    "createdAt"?: string;
    /**
     * 
     */
    "pdf": string;
    /**
     * 
     */
    "owner": string;
}

export interface InlineResponse2006 {
    /**
     * 
     */
    "results": Array<InlineResponse2006Results>;
    /**
     * 
     */
    "next": string;
    /**
     * 
     */
    "previous": string;
    /**
     * 
     */
    "count": number;
}

export interface InlineResponse2006Results {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "datafile"?: string;
    /**
     * 
     */
    "number"?: number;
    /**
     * 
     */
    "parentPdf"?: string;
}

export interface InlineResponse2007 {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "datafile": string;
    /**
     * 
     */
    "number": number;
    /**
     * 
     */
    "parentPdf": string;
}

export interface InlineResponse2008 {
    /**
     * 
     */
    "results": Array<InlineResponse2008Results>;
    /**
     * 
     */
    "next": string;
    /**
     * 
     */
    "previous": string;
    /**
     * 
     */
    "count": number;
}

export interface InlineResponse2008Results {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "email"?: string;
    /**
     * 
     */
    "document"?: string;
    /**
     * 
     */
    "user"?: string;
}

export interface InlineResponse2009 {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "email": string;
    /**
     * 
     */
    "document": string;
    /**
     * 
     */
    "user"?: string;
}

export interface InlineResponse200Results {
    /**
     * 
     */
    "id"?: number;
    /**
     * 
     */
    "number"?: number;
    /**
     * 
     */
    "template"?: string;
}



/**
 * AbstractPartyApi - fetch parameter creator
 */
export const AbstractPartyApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/abstractParty/
     * @param data 
     */
    abstractPartyCreate(params: {  "data"?: Data1; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/abstractParty/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     */
    abstractPartyDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractPartyDelete");
        }
        const baseUrl = `/v1.0/abstractParty/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/
     * @param page A page number within the paginated result set.
     */
    abstractPartyList(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/abstractParty/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     * @param data 
     */
    abstractPartyPartialUpdate(params: {  "id": number; "data"?: Data3; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractPartyPartialUpdate");
        }
        const baseUrl = `/v1.0/abstractParty/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     */
    abstractPartyRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractPartyRead");
        }
        const baseUrl = `/v1.0/abstractParty/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     * @param data 
     */
    abstractPartyUpdate(params: {  "id": number; "data"?: Data2; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractPartyUpdate");
        }
        const baseUrl = `/v1.0/abstractParty/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AbstractPartyApi - functional programming interface
 */
export const AbstractPartyApiFp = {
    /**
     * 
     * @summary /v1.0/abstractParty/
     * @param data 
     */
    abstractPartyCreate(params: { "data"?: Data1;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractPartyApiFetchParamCreator.abstractPartyCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     */
    abstractPartyDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractPartyApiFetchParamCreator.abstractPartyDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/
     * @param page A page number within the paginated result set.
     */
    abstractPartyList(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AbstractPartyApiFetchParamCreator.abstractPartyList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     * @param data 
     */
    abstractPartyPartialUpdate(params: { "id": number; "data"?: Data3;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractPartyApiFetchParamCreator.abstractPartyPartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     */
    abstractPartyRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AbstractPartyApiFetchParamCreator.abstractPartyRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     * @param data 
     */
    abstractPartyUpdate(params: { "id": number; "data"?: Data2;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractPartyApiFetchParamCreator.abstractPartyUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AbstractPartyApi - object-oriented interface
 */
export class AbstractPartyApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/abstractParty/
     * @param data 
     */
    abstractPartyCreate(params: {  "data"?: Data1; }, options?: any) {
        return AbstractPartyApiFp.abstractPartyCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     */
    abstractPartyDelete(params: {  "id": number; }, options?: any) {
        return AbstractPartyApiFp.abstractPartyDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractParty/
     * @param page A page number within the paginated result set.
     */
    abstractPartyList(params: {  "page"?: number; }, options?: any) {
        return AbstractPartyApiFp.abstractPartyList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     * @param data 
     */
    abstractPartyPartialUpdate(params: {  "id": number; "data"?: Data3; }, options?: any) {
        return AbstractPartyApiFp.abstractPartyPartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     */
    abstractPartyRead(params: {  "id": number; }, options?: any) {
        return AbstractPartyApiFp.abstractPartyRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractParty/{id}/
     * @param id A unique integer value identifying this abstract party.
     * @param data 
     */
    abstractPartyUpdate(params: {  "id": number; "data"?: Data2; }, options?: any) {
        return AbstractPartyApiFp.abstractPartyUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AbstractPartyApi - factory interface
 */
export const AbstractPartyApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/abstractParty/
         * @param data 
         */
        abstractPartyCreate(params: {  "data"?: Data1; }, options?: any) {
            return AbstractPartyApiFp.abstractPartyCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractParty/{id}/
         * @param id A unique integer value identifying this abstract party.
         */
        abstractPartyDelete(params: {  "id": number; }, options?: any) {
            return AbstractPartyApiFp.abstractPartyDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractParty/
         * @param page A page number within the paginated result set.
         */
        abstractPartyList(params: {  "page"?: number; }, options?: any) {
            return AbstractPartyApiFp.abstractPartyList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractParty/{id}/
         * @param id A unique integer value identifying this abstract party.
         * @param data 
         */
        abstractPartyPartialUpdate(params: {  "id": number; "data"?: Data3; }, options?: any) {
            return AbstractPartyApiFp.abstractPartyPartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractParty/{id}/
         * @param id A unique integer value identifying this abstract party.
         */
        abstractPartyRead(params: {  "id": number; }, options?: any) {
            return AbstractPartyApiFp.abstractPartyRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractParty/{id}/
         * @param id A unique integer value identifying this abstract party.
         * @param data 
         */
        abstractPartyUpdate(params: {  "id": number; "data"?: Data2; }, options?: any) {
            return AbstractPartyApiFp.abstractPartyUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * AbstractSignatureApi - fetch parameter creator
 */
export const AbstractSignatureApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/abstractSignature/
     * @param data 
     */
    abstractSignatureCreate(params: {  "data"?: Data4; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/abstractSignature/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     */
    abstractSignatureDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractSignatureDelete");
        }
        const baseUrl = `/v1.0/abstractSignature/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/
     * @param page A page number within the paginated result set.
     */
    abstractSignatureList(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/abstractSignature/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     * @param data 
     */
    abstractSignaturePartialUpdate(params: {  "id": number; "data"?: Data6; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractSignaturePartialUpdate");
        }
        const baseUrl = `/v1.0/abstractSignature/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     */
    abstractSignatureRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractSignatureRead");
        }
        const baseUrl = `/v1.0/abstractSignature/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     * @param data 
     */
    abstractSignatureUpdate(params: {  "id": number; "data"?: Data5; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling abstractSignatureUpdate");
        }
        const baseUrl = `/v1.0/abstractSignature/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AbstractSignatureApi - functional programming interface
 */
export const AbstractSignatureApiFp = {
    /**
     * 
     * @summary /v1.0/abstractSignature/
     * @param data 
     */
    abstractSignatureCreate(params: { "data"?: Data4;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractSignatureApiFetchParamCreator.abstractSignatureCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     */
    abstractSignatureDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractSignatureApiFetchParamCreator.abstractSignatureDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/
     * @param page A page number within the paginated result set.
     */
    abstractSignatureList(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AbstractSignatureApiFetchParamCreator.abstractSignatureList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     * @param data 
     */
    abstractSignaturePartialUpdate(params: { "id": number; "data"?: Data6;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractSignatureApiFetchParamCreator.abstractSignaturePartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     */
    abstractSignatureRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AbstractSignatureApiFetchParamCreator.abstractSignatureRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     * @param data 
     */
    abstractSignatureUpdate(params: { "id": number; "data"?: Data5;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AbstractSignatureApiFetchParamCreator.abstractSignatureUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AbstractSignatureApi - object-oriented interface
 */
export class AbstractSignatureApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/abstractSignature/
     * @param data 
     */
    abstractSignatureCreate(params: {  "data"?: Data4; }, options?: any) {
        return AbstractSignatureApiFp.abstractSignatureCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     */
    abstractSignatureDelete(params: {  "id": number; }, options?: any) {
        return AbstractSignatureApiFp.abstractSignatureDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractSignature/
     * @param page A page number within the paginated result set.
     */
    abstractSignatureList(params: {  "page"?: number; }, options?: any) {
        return AbstractSignatureApiFp.abstractSignatureList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     * @param data 
     */
    abstractSignaturePartialUpdate(params: {  "id": number; "data"?: Data6; }, options?: any) {
        return AbstractSignatureApiFp.abstractSignaturePartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     */
    abstractSignatureRead(params: {  "id": number; }, options?: any) {
        return AbstractSignatureApiFp.abstractSignatureRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/abstractSignature/{id}/
     * @param id A unique integer value identifying this abstract signature.
     * @param data 
     */
    abstractSignatureUpdate(params: {  "id": number; "data"?: Data5; }, options?: any) {
        return AbstractSignatureApiFp.abstractSignatureUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AbstractSignatureApi - factory interface
 */
export const AbstractSignatureApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/abstractSignature/
         * @param data 
         */
        abstractSignatureCreate(params: {  "data"?: Data4; }, options?: any) {
            return AbstractSignatureApiFp.abstractSignatureCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractSignature/{id}/
         * @param id A unique integer value identifying this abstract signature.
         */
        abstractSignatureDelete(params: {  "id": number; }, options?: any) {
            return AbstractSignatureApiFp.abstractSignatureDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractSignature/
         * @param page A page number within the paginated result set.
         */
        abstractSignatureList(params: {  "page"?: number; }, options?: any) {
            return AbstractSignatureApiFp.abstractSignatureList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractSignature/{id}/
         * @param id A unique integer value identifying this abstract signature.
         * @param data 
         */
        abstractSignaturePartialUpdate(params: {  "id": number; "data"?: Data6; }, options?: any) {
            return AbstractSignatureApiFp.abstractSignaturePartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractSignature/{id}/
         * @param id A unique integer value identifying this abstract signature.
         */
        abstractSignatureRead(params: {  "id": number; }, options?: any) {
            return AbstractSignatureApiFp.abstractSignatureRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/abstractSignature/{id}/
         * @param id A unique integer value identifying this abstract signature.
         * @param data 
         */
        abstractSignatureUpdate(params: {  "id": number; "data"?: Data5; }, options?: any) {
            return AbstractSignatureApiFp.abstractSignatureUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * ApitokenauthApi - fetch parameter creator
 */
export const ApitokenauthApiFetchParamCreator = {
    /**
     * API View that receives a POST with a user's username and password.  Returns a JSON Web Token that can be used for authenticated requests.
     * @summary /api-token-auth/
     * @param data 
     */
    apiTokenAuthCreate(params: {  "data"?: Data; }, options?: any): FetchArgs {
        const baseUrl = `/api-token-auth/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            console.log("params[data]", JSON.stringify(params["data"]));
            
            fetchOptions.body = JSON.stringify(params["data"] || {});
            console.log(fetchOptions.body);
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ApitokenauthApi - functional programming interface
 */
export const ApitokenauthApiFp = {
    /**
     * API View that receives a POST with a user's username and password.  Returns a JSON Web Token that can be used for authenticated requests.
     * @summary /api-token-auth/
     * @param data 
     */
    apiTokenAuthCreate(params: { "data"?: Data;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApitokenauthApiFetchParamCreator.apiTokenAuthCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            console.log(basePath + fetchArgs.url);
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ApitokenauthApi - object-oriented interface
 */
export class ApitokenauthApi extends BaseAPI {
    /**
     * API View that receives a POST with a user's username and password.  Returns a JSON Web Token that can be used for authenticated requests.
     * @summary /api-token-auth/
     * @param data 
     */
    apiTokenAuthCreate(params: {  "data"?: Data; }, options?: any) {
        console.log("params apiTokenAuthCreate",params.data);
        return ApitokenauthApiFp.apiTokenAuthCreate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ApitokenauthApi - factory interface
 */
export const ApitokenauthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * API View that receives a POST with a user's username and password.  Returns a JSON Web Token that can be used for authenticated requests.
         * @summary /api-token-auth/
         * @param data 
         */
        apiTokenAuthCreate(params: {  "data"?: Data; }, options?: any) {
            return ApitokenauthApiFp.apiTokenAuthCreate(params, options)(fetch, basePath);
        },
    };
};


/**
 * DocumentApi - fetch parameter creator
 */
export const DocumentApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/document/
     * @param data 
     */
    documentCreate(params: {  "data"?: Data7; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/document/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     */
    documentDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling documentDelete");
        }
        const baseUrl = `/v1.0/document/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/document/
     * @param page A page number within the paginated result set.
     */
    documentList(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/document/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     * @param data 
     */
    documentPartialUpdate(params: {  "id": number; "data"?: Data9; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling documentPartialUpdate");
        }
        const baseUrl = `/v1.0/document/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     */
    documentRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling documentRead");
        }
        const baseUrl = `/v1.0/document/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     * @param data 
     */
    documentUpdate(params: {  "id": number; "data"?: Data8; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling documentUpdate");
        }
        const baseUrl = `/v1.0/document/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DocumentApi - functional programming interface
 */
export const DocumentApiFp = {
    /**
     * 
     * @summary /v1.0/document/
     * @param data 
     */
    documentCreate(params: { "data"?: Data7;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DocumentApiFetchParamCreator.documentCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     */
    documentDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DocumentApiFetchParamCreator.documentDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/document/
     * @param page A page number within the paginated result set.
     */
    documentList(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = DocumentApiFetchParamCreator.documentList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     * @param data 
     */
    documentPartialUpdate(params: { "id": number; "data"?: Data9;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DocumentApiFetchParamCreator.documentPartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     */
    documentRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
        const fetchArgs = DocumentApiFetchParamCreator.documentRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     * @param data 
     */
    documentUpdate(params: { "id": number; "data"?: Data8;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DocumentApiFetchParamCreator.documentUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DocumentApi - object-oriented interface
 */
export class DocumentApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/document/
     * @param data 
     */
    documentCreate(params: {  "data"?: Data7; }, options?: any) {
        return DocumentApiFp.documentCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     */
    documentDelete(params: {  "id": number; }, options?: any) {
        return DocumentApiFp.documentDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/document/
     * @param page A page number within the paginated result set.
     */
    documentList(params: {  "page"?: number; }, options?: any) {
        return DocumentApiFp.documentList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     * @param data 
     */
    documentPartialUpdate(params: {  "id": number; "data"?: Data9; }, options?: any) {
        return DocumentApiFp.documentPartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     */
    documentRead(params: {  "id": number; }, options?: any) {
        return DocumentApiFp.documentRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/document/{id}/
     * @param id A unique integer value identifying this document.
     * @param data 
     */
    documentUpdate(params: {  "id": number; "data"?: Data8; }, options?: any) {
        return DocumentApiFp.documentUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DocumentApi - factory interface
 */
export const DocumentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/document/
         * @param data 
         */
        documentCreate(params: {  "data"?: Data7; }, options?: any) {
            return DocumentApiFp.documentCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/document/{id}/
         * @param id A unique integer value identifying this document.
         */
        documentDelete(params: {  "id": number; }, options?: any) {
            return DocumentApiFp.documentDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/document/
         * @param page A page number within the paginated result set.
         */
        documentList(params: {  "page"?: number; }, options?: any) {
            return DocumentApiFp.documentList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/document/{id}/
         * @param id A unique integer value identifying this document.
         * @param data 
         */
        documentPartialUpdate(params: {  "id": number; "data"?: Data9; }, options?: any) {
            return DocumentApiFp.documentPartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/document/{id}/
         * @param id A unique integer value identifying this document.
         */
        documentRead(params: {  "id": number; }, options?: any) {
            return DocumentApiFp.documentRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/document/{id}/
         * @param id A unique integer value identifying this document.
         * @param data 
         */
        documentUpdate(params: {  "id": number; "data"?: Data8; }, options?: any) {
            return DocumentApiFp.documentUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * PageApi - fetch parameter creator
 */
export const PageApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/page/
     * @param data 
     */
    pageCreate(params: {  "data"?: Data10; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/page/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     */
    pageDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pageDelete");
        }
        const baseUrl = `/v1.0/page/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/page/
     * @param page A page number within the paginated result set.
     * @param parentPdf 
     */
    pageList(params: {  "page"?: number; "parentPdf"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/page/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
            "parent_pdf": params["parentPdf"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     * @param data 
     */
    pagePartialUpdate(params: {  "id": number; "data"?: Data12; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pagePartialUpdate");
        }
        const baseUrl = `/v1.0/page/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     */
    pageRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pageRead");
        }
        const baseUrl = `/v1.0/page/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     * @param data 
     */
    pageUpdate(params: {  "id": number; "data"?: Data11; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pageUpdate");
        }
        const baseUrl = `/v1.0/page/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PageApi - functional programming interface
 */
export const PageApiFp = {
    /**
     * 
     * @summary /v1.0/page/
     * @param data 
     */
    pageCreate(params: { "data"?: Data10;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PageApiFetchParamCreator.pageCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     */
    pageDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PageApiFetchParamCreator.pageDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/page/
     * @param page A page number within the paginated result set.
     * @param parentPdf 
     */
    pageList(params: { "page"?: number; "parentPdf"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
        const fetchArgs = PageApiFetchParamCreator.pageList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     * @param data 
     */
    pagePartialUpdate(params: { "id": number; "data"?: Data12;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PageApiFetchParamCreator.pagePartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     */
    pageRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
        const fetchArgs = PageApiFetchParamCreator.pageRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     * @param data 
     */
    pageUpdate(params: { "id": number; "data"?: Data11;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PageApiFetchParamCreator.pageUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PageApi - object-oriented interface
 */
export class PageApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/page/
     * @param data 
     */
    pageCreate(params: {  "data"?: Data10; }, options?: any) {
        return PageApiFp.pageCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     */
    pageDelete(params: {  "id": number; }, options?: any) {
        return PageApiFp.pageDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/page/
     * @param page A page number within the paginated result set.
     * @param parentPdf 
     */
    pageList(params: {  "page"?: number; "parentPdf"?: string; }, options?: any) {
        return PageApiFp.pageList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     * @param data 
     */
    pagePartialUpdate(params: {  "id": number; "data"?: Data12; }, options?: any) {
        return PageApiFp.pagePartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     */
    pageRead(params: {  "id": number; }, options?: any) {
        return PageApiFp.pageRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/page/{id}/
     * @param id A unique integer value identifying this page.
     * @param data 
     */
    pageUpdate(params: {  "id": number; "data"?: Data11; }, options?: any) {
        return PageApiFp.pageUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PageApi - factory interface
 */
export const PageApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/page/
         * @param data 
         */
        pageCreate(params: {  "data"?: Data10; }, options?: any) {
            return PageApiFp.pageCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/page/{id}/
         * @param id A unique integer value identifying this page.
         */
        pageDelete(params: {  "id": number; }, options?: any) {
            return PageApiFp.pageDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/page/
         * @param page A page number within the paginated result set.
         * @param parentPdf 
         */
        pageList(params: {  "page"?: number; "parentPdf"?: string; }, options?: any) {
            return PageApiFp.pageList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/page/{id}/
         * @param id A unique integer value identifying this page.
         * @param data 
         */
        pagePartialUpdate(params: {  "id": number; "data"?: Data12; }, options?: any) {
            return PageApiFp.pagePartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/page/{id}/
         * @param id A unique integer value identifying this page.
         */
        pageRead(params: {  "id": number; }, options?: any) {
            return PageApiFp.pageRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/page/{id}/
         * @param id A unique integer value identifying this page.
         * @param data 
         */
        pageUpdate(params: {  "id": number; "data"?: Data11; }, options?: any) {
            return PageApiFp.pageUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * PartyApi - fetch parameter creator
 */
export const PartyApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/party/
     * @param data 
     */
    partyCreate(params: {  "data"?: Data13; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/party/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     */
    partyDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling partyDelete");
        }
        const baseUrl = `/v1.0/party/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/party/
     * @param page A page number within the paginated result set.
     */
    partyList(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/party/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     * @param data 
     */
    partyPartialUpdate(params: {  "id": number; "data"?: Data15; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling partyPartialUpdate");
        }
        const baseUrl = `/v1.0/party/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     */
    partyRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling partyRead");
        }
        const baseUrl = `/v1.0/party/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     * @param data 
     */
    partyUpdate(params: {  "id": number; "data"?: Data14; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling partyUpdate");
        }
        const baseUrl = `/v1.0/party/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PartyApi - functional programming interface
 */
export const PartyApiFp = {
    /**
     * 
     * @summary /v1.0/party/
     * @param data 
     */
    partyCreate(params: { "data"?: Data13;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PartyApiFetchParamCreator.partyCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     */
    partyDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PartyApiFetchParamCreator.partyDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/party/
     * @param page A page number within the paginated result set.
     */
    partyList(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
        const fetchArgs = PartyApiFetchParamCreator.partyList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     * @param data 
     */
    partyPartialUpdate(params: { "id": number; "data"?: Data15;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PartyApiFetchParamCreator.partyPartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     */
    partyRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
        const fetchArgs = PartyApiFetchParamCreator.partyRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     * @param data 
     */
    partyUpdate(params: { "id": number; "data"?: Data14;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PartyApiFetchParamCreator.partyUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PartyApi - object-oriented interface
 */
export class PartyApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/party/
     * @param data 
     */
    partyCreate(params: {  "data"?: Data13; }, options?: any) {
        return PartyApiFp.partyCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     */
    partyDelete(params: {  "id": number; }, options?: any) {
        return PartyApiFp.partyDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/party/
     * @param page A page number within the paginated result set.
     */
    partyList(params: {  "page"?: number; }, options?: any) {
        return PartyApiFp.partyList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     * @param data 
     */
    partyPartialUpdate(params: {  "id": number; "data"?: Data15; }, options?: any) {
        return PartyApiFp.partyPartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     */
    partyRead(params: {  "id": number; }, options?: any) {
        return PartyApiFp.partyRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/party/{id}/
     * @param id A unique integer value identifying this party.
     * @param data 
     */
    partyUpdate(params: {  "id": number; "data"?: Data14; }, options?: any) {
        return PartyApiFp.partyUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PartyApi - factory interface
 */
export const PartyApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/party/
         * @param data 
         */
        partyCreate(params: {  "data"?: Data13; }, options?: any) {
            return PartyApiFp.partyCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/party/{id}/
         * @param id A unique integer value identifying this party.
         */
        partyDelete(params: {  "id": number; }, options?: any) {
            return PartyApiFp.partyDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/party/
         * @param page A page number within the paginated result set.
         */
        partyList(params: {  "page"?: number; }, options?: any) {
            return PartyApiFp.partyList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/party/{id}/
         * @param id A unique integer value identifying this party.
         * @param data 
         */
        partyPartialUpdate(params: {  "id": number; "data"?: Data15; }, options?: any) {
            return PartyApiFp.partyPartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/party/{id}/
         * @param id A unique integer value identifying this party.
         */
        partyRead(params: {  "id": number; }, options?: any) {
            return PartyApiFp.partyRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/party/{id}/
         * @param id A unique integer value identifying this party.
         * @param data 
         */
        partyUpdate(params: {  "id": number; "data"?: Data14; }, options?: any) {
            return PartyApiFp.partyUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * PdfApi - fetch parameter creator
 */
export const PdfApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/pdf/
     * @param data 
     */
    pdfCreate(params: {  "data"?: Data16; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/pdf/`;
        let urlObj = url.parse(baseUrl, true);
        
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     */
    pdfDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pdfDelete");
        }
        const baseUrl = `/v1.0/pdf/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/
     * @param page A page number within the paginated result set.
     */
    pdfList(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/pdf/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET"  }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     * @param data 
     */
    pdfPartialUpdate(params: {  "id": number; "data"?: Data18; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pdfPartialUpdate");
        }
        const baseUrl = `/v1.0/pdf/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     */
    pdfRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pdfRead");
        }
        const baseUrl = `/v1.0/pdf/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        console.log("pdfRead1",  url.format(urlObj));
        console.log("pdfRead1",  fetchOptions);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     * @param data 
     */
    pdfUpdate(params: {  "id": number; "data"?: Data17; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pdfUpdate");
        }
        const baseUrl = `/v1.0/pdf/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PdfApi - functional programming interface
 */
export const PdfApiFp = {
    /**
     * 
     * @summary /v1.0/pdf/
     * @param data 
     */
    pdfCreate(params: { "data"?: Data16;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfApiFetchParamCreator.pdfCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     */
    pdfDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfApiFetchParamCreator.pdfDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/
     * @param page A page number within the paginated result set.
     */
    pdfList(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
        const fetchArgs = PdfApiFetchParamCreator.pdfList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     * @param data 
     */
    pdfPartialUpdate(params: { "id": number; "data"?: Data18;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfApiFetchParamCreator.pdfPartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     */
    pdfRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
        const fetchArgs = PdfApiFetchParamCreator.pdfRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     * @param data 
     */
    pdfUpdate(params: { "id": number; "data"?: Data17;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfApiFetchParamCreator.pdfUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PdfApi - object-oriented interface
 */
export class PdfApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/pdf/
     * @param data 
     */
    pdfCreate(params: {  "data"?: Data16; }, options?: any) {
        return PdfApiFp.pdfCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     */
    pdfDelete(params: {  "id": number; }, options?: any) {
        return PdfApiFp.pdfDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/pdf/
     * @param page A page number within the paginated result set.
     */
    pdfList(params: {  "page"?: number; }, options?: any) {
        return PdfApiFp.pdfList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     * @param data 
     */
    pdfPartialUpdate(params: {  "id": number; "data"?: Data18; }, options?: any) {
        return PdfApiFp.pdfPartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     */
    pdfRead(params: {  "id": number; }, options?: any) {
        return PdfApiFp.pdfRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/pdf/{id}/
     * @param id A unique integer value identifying this pdf.
     * @param data 
     */
    pdfUpdate(params: {  "id": number; "data"?: Data17; }, options?: any) {
        return PdfApiFp.pdfUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PdfApi - factory interface
 */
export const PdfApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/pdf/
         * @param data 
         */
        pdfCreate(params: {  "data"?: Data16; }, options?: any) {
            return PdfApiFp.pdfCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/pdf/{id}/
         * @param id A unique integer value identifying this pdf.
         */
        pdfDelete(params: {  "id": number; }, options?: any) {
            return PdfApiFp.pdfDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/pdf/
         * @param page A page number within the paginated result set.
         */
        pdfList(params: {  "page"?: number; }, options?: any) {
            return PdfApiFp.pdfList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/pdf/{id}/
         * @param id A unique integer value identifying this pdf.
         * @param data 
         */
        pdfPartialUpdate(params: {  "id": number; "data"?: Data18; }, options?: any) {
            return PdfApiFp.pdfPartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/pdf/{id}/
         * @param id A unique integer value identifying this pdf.
         */
        pdfRead(params: {  "id": number; }, options?: any) {
            return PdfApiFp.pdfRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/pdf/{id}/
         * @param id A unique integer value identifying this pdf.
         * @param data 
         */
        pdfUpdate(params: {  "id": number; "data"?: Data17; }, options?: any) {
            return PdfApiFp.pdfUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * SchemaApi - fetch parameter creator
 */
export const SchemaApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/schema/
     */
    schemaList(options?: any): FetchArgs {
        const baseUrl = `/v1.0/schema/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SchemaApi - functional programming interface
 */
export const SchemaApiFp = {
    /**
     * 
     * @summary /v1.0/schema/
     */
    schemaList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SchemaApiFetchParamCreator.schemaList(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SchemaApi - object-oriented interface
 */
export class SchemaApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/schema/
     */
    schemaList(options?: any) {
        return SchemaApiFp.schemaList(options)(this.fetch, this.basePath);
    }
};

/**
 * SchemaApi - factory interface
 */
export const SchemaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/schema/
         */
        schemaList(options?: any) {
            return SchemaApiFp.schemaList(options)(fetch, basePath);
        },
    };
};


/**
 * TemplateApi - fetch parameter creator
 */
export const TemplateApiFetchParamCreator = {
    /**
     * 
     * @summary /v1.0/template/
     * @param data 
     */
    templateCreate(params: {  "data"?: Data19; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/template/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     */
    templateDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling templateDelete");
        }
        const baseUrl = `/v1.0/template/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/template/
     * @param page A page number within the paginated result set.
     */
    templateList(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/v1.0/template/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     * @param data 
     */
    templatePartialUpdate(params: {  "id": number; "data"?: Data21; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling templatePartialUpdate");
        }
        const baseUrl = `/v1.0/template/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     */
    templateRead(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling templateRead");
        }
        const baseUrl = `/v1.0/template/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     * @param data 
     */
    templateUpdate(params: {  "id": number; "data"?: Data20; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling templateUpdate");
        }
        const baseUrl = `/v1.0/template/{id}/`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TemplateApi - functional programming interface
 */
export const TemplateApiFp = {
    /**
     * 
     * @summary /v1.0/template/
     * @param data 
     */
    templateCreate(params: { "data"?: Data19;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TemplateApiFetchParamCreator.templateCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     */
    templateDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TemplateApiFetchParamCreator.templateDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/template/
     * @param page A page number within the paginated result set.
     */
    templateList(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = TemplateApiFetchParamCreator.templateList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     * @param data 
     */
    templatePartialUpdate(params: { "id": number; "data"?: Data21;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TemplateApiFetchParamCreator.templatePartialUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     */
    templateRead(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
        const fetchArgs = TemplateApiFetchParamCreator.templateRead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            console.log("templateRead1",basePath + fetchArgs.url);
            console.log("templateRead1",fetchArgs.options);

            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     * @param data 
     */
    templateUpdate(params: { "id": number; "data"?: Data20;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TemplateApiFetchParamCreator.templateUpdate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TemplateApi - object-oriented interface
 */
export class TemplateApi extends BaseAPI {
    /**
     * 
     * @summary /v1.0/template/
     * @param data 
     */
    templateCreate(params: {  "data"?: Data19; }, options?: any) {
        return TemplateApiFp.templateCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     */
    templateDelete(params: {  "id": number; }, options?: any) {
        return TemplateApiFp.templateDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/template/
     * @param page A page number within the paginated result set.
     */
    templateList(params: {  "page"?: number; }, options?: any) {
        return TemplateApiFp.templateList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     * @param data 
     */
    templatePartialUpdate(params: {  "id": number; "data"?: Data21; }, options?: any) {
        return TemplateApiFp.templatePartialUpdate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     */
    templateRead(params: {  "id": number; }, options?: any) {
        return TemplateApiFp.templateRead(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary /v1.0/template/{id}/
     * @param id A unique integer value identifying this template.
     * @param data 
     */
    templateUpdate(params: {  "id": number; "data"?: Data20; }, options?: any) {
        return TemplateApiFp.templateUpdate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TemplateApi - factory interface
 */
export const TemplateApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /v1.0/template/
         * @param data 
         */
        templateCreate(params: {  "data"?: Data19; }, options?: any) {
            return TemplateApiFp.templateCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/template/{id}/
         * @param id A unique integer value identifying this template.
         */
        templateDelete(params: {  "id": number; }, options?: any) {
            return TemplateApiFp.templateDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/template/
         * @param page A page number within the paginated result set.
         */
        templateList(params: {  "page"?: number; }, options?: any) {
            return TemplateApiFp.templateList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/template/{id}/
         * @param id A unique integer value identifying this template.
         * @param data 
         */
        templatePartialUpdate(params: {  "id": number; "data"?: Data21; }, options?: any) {
            return TemplateApiFp.templatePartialUpdate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/template/{id}/
         * @param id A unique integer value identifying this template.
         */
        templateRead(params: {  "id": number; }, options?: any) {
            return TemplateApiFp.templateRead(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary /v1.0/template/{id}/
         * @param id A unique integer value identifying this template.
         * @param data 
         */
        templateUpdate(params: {  "id": number; "data"?: Data20; }, options?: any) {
            return TemplateApiFp.templateUpdate(params, options)(fetch, basePath);
        },
    };
};


/**
 * UploadpdfApi - fetch parameter creator
 */
export const UploadpdfApiFetchParamCreator = {
    /**
     * 
     * @summary /upload-pdf/
     */
    uploadPdfCreate(options?: any): FetchArgs {
        const baseUrl = `/upload-pdf/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);
        fetchOptions.headers = fetchOptions.headers || {};
        fetchOptions.headers.Authorization = "JWT " + localStorage.getItem("usertoken");

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UploadpdfApi - functional programming interface
 */
export const UploadpdfApiFp = {
    /**
     * 
     * @summary /upload-pdf/
     */
    uploadPdfCreate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UploadpdfApiFetchParamCreator.uploadPdfCreate(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            console.log("uploadPdf1",basePath + fetchArgs.url);
            console.log("uploadPdf1",fetchArgs.options);
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UploadpdfApi - object-oriented interface
 */
export class UploadpdfApi extends BaseAPI {
    /**
     * 
     * @summary /upload-pdf/
     */
    uploadPdfCreate(options?: any) {
        return UploadpdfApiFp.uploadPdfCreate(options)(this.fetch, this.basePath);
    }
};

/**
 * UploadpdfApi - factory interface
 */
export const UploadpdfApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary /upload-pdf/
         */
        uploadPdfCreate(options?: any) {
            return UploadpdfApiFp.uploadPdfCreate(options)(fetch, basePath);
        },
    };
};

